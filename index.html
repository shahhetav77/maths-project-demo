<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>3D Matrix Transformation Simulator (Space Shuttle)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <style>
        /* (The CSS is identical to the mobile-friendly version) */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.5; background-color: #f0f2f5; color: #333; margin: 0; }
        #controls { width: 100%; padding: 20px; background-color: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow-y: auto; box-sizing: border-box; max-height: 50vh; }
        h1 { font-size: 1.5em; text-align: center; color: #2c3e50; border-bottom: 2px solid #e74c3c; padding-bottom: 10px; margin-top: 0; }
        h2 { font-size: 1.1em; color: #34495e; margin-top: 20px; margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: flex; justify-content: space-between; font-size: 0.9em; font-weight: bold; }
        .control-group label span { font-weight: normal; color: #e74c3c; font-family: 'Courier New', Courier, monospace; }
        input[type="range"] { width: 100%; }
        #scene-container { width: 100%; height: 50vh; background-color: #222; }
        canvas { display: block; }
        #matrix-display { background-color: #ecf0f1; padding: 15px; border-radius: 5px; font-family: 'Courier New', Courier, monospace; font-size: 1.1em; line-height: 1.4; display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; text-align: right; }
        #matrix-display span { padding: 5px; background: #fff; border: 1px solid #bdc3c7; border-radius: 3px; }
        button#reset-btn { width: 100%; padding: 10px; background-color: #e74c3c; color: white; border: none; border-radius: 5px; font-size: 1em; font-weight: bold; cursor: pointer; margin-top: 10px; }
        button#reset-btn:hover { background-color: #c0392b; }
        
        @media (min-width: 769px) {
            body { display: flex; height: 100vh; }
            #controls { width: 350px; height: 100vh; max-height: 100vh; }
            #scene-container { flex-grow: 1; height: 100vh; }
        }
    </style>
</head>
<body>

    <div id="controls">
        <h1>3D Transformations</h1>
        <h2>1. Translation (Tx, Ty, Tz)</h2>
        <div class="control-group"><label for="tx">Translate X <span>0.0</span></label><input type="range" id="tx" min="-5" max="5" value="0" step="0.1"></div>
        <div class="control-group"><label for="ty">Translate Y <span>0.0</span></label><input type="range" id="ty" min="-5" max="5" value="0" step="0.1"></div>
        <div class="control-group"><label for="tz">Translate Z <span>0.0</span></label><input type="range" id="tz" min="-5" max="5" value="0" step="0.1"></div>
        <h2>2. Rotation (Rx, Ry, Rz)</h2>
        <div class="control-group"><label for="rx">Rotate X (Pitch) <span>0째</span></label><input type="range" id="rx" min="-180" max="180" value="0" step="1"></div>
        <div class="control-group"><label for="ry">Rotate Y (Yaw) <span>0째</span></label><input type="range" id="ry" min="-180" max="180" value="0" step="1"></div>
        <div class="control-group"><label for="rz">Rotate Z (Roll) <span>0째</span></label><input type="range" id="rz" min="-180" max="180" value="0" step="1"></div>
        <h2>3. Scaling (Sx, Sy, Sz)</h2>
        <div class="control-group"><label for="sx">Scale X <span>1.0</span></label><input type="range" id="sx" min="0.1" max="3" value="1" step="0.1"></div>
        <div class="control-group"><label for="sy">Scale Y <span>1.0</span></label><input type="range" id="sy" min="0.1" max="3" value="1" step="0.1"></div>
        <div class="control-group"><label for="sz">Scale Z <span>1.0</span></label><input type="range" id="sz" min="0.1" max="3" value="1" step="0.1"></div>
        <h2>4. Shearing (Sh)</h2>
        <div class="control-group"><label for="sh_xy">Shear X by Y (sh_xy) <span>0.0</span></label><input type="range" id="sh_xy" min="-1" max="1" value="0" step="0.1"></div>
        <div class="control-group"><label for="sh_yx">Shear Y by X (sh_yx) <span>0.0</span></label><input type="range" id="sh_yx" min="-1" max="1" value="0" step="0.1"></div>
        <h2>Final 4x4 Model Matrix</h2>
        <div id="matrix-display"></div>
        <button id="reset-btn">Reset All Values</button>
    </div>

    <div id="scene-container"></div>


    <script>
        // --- 1. GLOBAL VARIABLES ---
        let scene, camera, renderer, controls;
        
        // (CHANGED) We replace 'cube' with 'model'
        let model, originalModel; 
        
        const sliders = {};
        const sliderOutputs = {};
        const matrixSpans = [];
        
        // --- 2. INITIALIZATION ---
        function init() {
            const container = document.getElementById('scene-container');

            // --- Scene, Camera, Renderer, Controls ---
            // (This is all the same as before)
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(3, 4, 7); 
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            container.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0); 
            controls.update();

            // --- Lighting ---
            // (Increased light to see the model better)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 2, 1);
            scene.add(directionalLight);

            // --- Helpers (Grid/Axes) ---
            scene.add(new THREE.GridHelper(10, 10, 0x888888, 0x444444));
            scene.add(new THREE.AxesHelper(3));


            // --- (NEW) LOAD THE 3D MODEL ---
            const loader = new THREE.GLTFLoader();
            const modelUrl = 'https://threejs.org/examples/models/gltf/Shuttle.glb';

            loader.load(modelUrl, function (gltf) {
                // --- This function runs when the model is finished loading ---
                
                // 1. Get the main model
                model = gltf.scene;
                
                // (Optional) Scale the model down if it's too big
                model.scale.set(0.5, 0.5, 0.5); 
                
                // THIS IS KEY: We will control the matrix manually
                model.matrixAutoUpdate = false; 
                scene.add(model);

                // 2. Create the "ghost" model
                originalModel = model.clone();
                const wireframeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                
                // Apply wireframe to all parts of the cloned model
                originalModel.traverse((node) => {
                    if (node.isMesh) {
                        node.material = wireframeMaterial;
                    }
                });
                scene.add(originalModel);

                // 3. Now that the model is loaded, apply initial slider values
                updateModel();
                
            }, undefined, function (error) {
                console.error('An error happened while loading the model:', error);
            });


            // --- Link UI Elements ---
            const controlIds = [
                'tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'sx', 'sy', 'sz', 'sh_xy', 'sh_yx'
            ];
            
            controlIds.forEach(id => {
                sliders[id] = document.getElementById(id);
                sliderOutputs[id] = document.querySelector(`label[for="${id}"] span`);
                // (CHANGED) Call updateModel instead of updateCube
                sliders[id].addEventListener('input', updateModel);
            });
            
            const matrixContainer = document.getElementById('matrix-display');
            for (let i = 0; i < 16; i++) {
                const span = document.createElement('span');
                matrixContainer.appendChild(span);
                matrixSpans.push(span);
            }
            
            document.getElementById('reset-btn').addEventListener('click', resetValues);
            window.addEventListener('resize', onWindowResize);
            onWindowResize(); 
            
            // We can't call updateModel() here anymore, 
            // because the 'model' doesn't exist yet!
        }

        // --- 3. THE UPDATE MODEL FUNCTION ---
        // (CHANGED) Renamed from updateCube to updateModel
        function updateModel() {
            // This stops errors if the sliders are moved before the model loads
            if (!model) {
                return; 
            }

            // 1. Create all the individual transformation matrices
            const tx = parseFloat(sliders.tx.value);
            const ty = parseFloat(sliders.ty.value);
            const tz = parseFloat(sliders.tz.value);
            const matTranslate = new THREE.Matrix4().makeTranslation(tx, ty, tz);
            
            const rx = THREE.MathUtils.degToRad(parseFloat(sliders.rx.value));
            const ry = THREE.MathUtils.degToRad(parseFloat(sliders.ry.value));
            const rz = THREE.MathUtils.degToRad(parseFloat(sliders.rz.value));
            const euler = new THREE.Euler(rx, ry, rz, 'XYZ');
            const matRotate = new THREE.Matrix4().makeRotationFromEuler(euler);
            
            const sx = parseFloat(sliders.sx.value);
            const sy = parseFloat(sliders.sy.value);
            const sz = parseFloat(sliders.sz.value);
            const matScale = new THREE.Matrix4().makeScale(sx, sy, sz);

            const sh_xy = parseFloat(sliders.sh_xy.value);
            const sh_yx = parseFloat(sliders.sh_yx.value);
            const matShear = new THREE.Matrix4().identity();
            matShear.set( 1, sh_yx, 0, 0, sh_xy, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 );

            // 2. Combine the matrices
            // (CHANGED) Apply to 'model.matrix'
            model.matrix.identity(); // Reset
            model.matrix.multiply(matTranslate);
            model.matrix.multiply(matRotate);
            model.matrix.multiply(matShear);
            model.matrix.multiply(matScale);

            // 3. Update the UI
            updateUI();
        }
        
        // (CHANGED) Renamed from updateUI
        function updateUI() {
            // Update slider text
            for (const id in sliders) {
                let value = parseFloat(sliders[id].value);
                if (id.startsWith('r')) {
                    sliderOutputs[id].innerText = `${value.toFixed(0)}째`;
                } else {
                    sliderOutputs[id].innerText = `${value.toFixed(1)}`;
                }
            }
            
            // This stops errors if the UI updates before the model loads
            if (!model) {
                return;
            }
            
            // Update the 4x4 matrix display
            // (CHANGED) Read from 'model.matrix.elements'
            const elements = model.matrix.elements;
            for (let i = 0; i < 16; i++) {
                matrixSpans[i].innerText = elements[i].toFixed(2);
            }
        }
        
        function resetValues() {
            sliders.tx.value = 0; sliders.ty.value = 0; sliders.tz.value = 0;
            sliders.rx.value = 0; sliders.ry.value = 0; sliders.rz.value = 0;
            sliders.sx.value = 1; sliders.sy.value = 1; sliders.sz.value = 1;
            sliders.sh_xy.value = 0; sliders.sh_yx.value = 0;
            // (CHANGED) Call updateModel
            updateModel();
        }
        
        // --- 4. RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); IAmStillHere();
            renderer.render(scene, camera);
        }

        // --- 5. EVENT HANDLERS ---
        function onWindowResize() {
            const container = document.getElementById('scene-container');
            let newWidth, newHeight;
            
            if (window.innerWidth < 769) {
                newWidth = window.innerWidth;
                newHeight = window.innerHeight * 0.5; // 50vh
            } else {
                newWidth = window.innerWidth - 350; 
                newHeight = window.innerHeight;
            }
            
            container.style.width = `${newWidth}px`;
            container.style.height = `${newHeight}px`;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        }

        // --- 6. START THE SIMULATION ---
        init();
        animate();

    </script>
</body>
</html>
